*modified Brian Heltsley for CLEO use inside mc pkg 1/13/04
******************************************************************** 
*                                                                  * 
*                     BABAYAGA - VERSION 3.5                       * 
*                                                                  * 
*                    AN EVENT GENERATOR FOR                        * 
*                                                                  * 
*                  e+ e- ----> e+ e-  (gammas)                     * 
*                  e+ e- ----> mu+ mu- (gammas)                    * 
*                  e+ e- ----> gamma gamma (gammas)                * 
*                  e+ e- ----> pi+ pi- (gammas)                    *
*                                                                  * 
*     C.M. CARLONI CALAME                                          * 
*     G. MONTAGNA                                                  * 
*     O. NICROSINI                                                 * 
*     F. PICCININI                                                 * 
*                                                                  * 
*   1)  DIPARTIMENTO DI FISICA NUCLEARE E TEORICA                  * 
*       UNIVERSITA` DI PAVIA                                       * 
*   2)  INFN SEZIONE DI PAVIA                                      * 
*                                                                  * 
********************************************************************          
*                                                                  *
*  The program needs to be linked to the CERN library.             *
*                                                                  *
*  It reads the input data from the file 'input.txt', where        *
*  a detailed description of the input parameters can be found.    *
*                                                                  *
*  24/10/2002, RELEASE NOTE:		         		   *
*     BABAYAGA is an event generator for the processes given	   *
*     before, at flavour factories energies, including the 	   *
*     relevant radiative corrections in a QED Parton Shower	   *
*     approach. In particular, in the new 3.5 version, the 	   *
*     process e+e- ---> pi+pi- has been added. In this case, 	   *
*     only ISR corrections are taken into account by means	   *
*     of the PS. FSR can be switched off also in the mu+mu-        *
*     channel, for testing/comparison purposes.		           *
*     When appropriate, radiation coherence effects are    	   *
*     included for an accurate event description.		   *
*     The generated events can be stored in a file given as	   *
*     input. By default, the following variables are stored:	   *
*      								   *
*     QXH1, QYH1, QZH1: three momentum of the leading energetic	   *
*                       photon generated by the PS		   *
*     QXH2, QYH2, QZH2: three momentum of the next-to-leading	   *
*                       energetic PS photon			   *
*     PXE,PYE,PZE:      three momentum of the outgoing electron,   *
*		        muon, gamma or pion.			   *
*     PXP,PYP,PZP:      three momentum of the outgoing positron,   *
*		        anti-muon, gamma or anti-pion.		   *
*                                                                  *
*     The subroutines CUTUSER and CUTS_ON_PHOTONS implement the    *
*     experimental selection criteria and can be modified by the   *
*     user. The function PFFM2 gives the squared of the Pion Form  *
*     Factor and can be modified by the user. The subroutine       *
*     FILL_EVENT fills the array event(12), which is stored in the *
*     ntuple-file. Also this routine can be modified in order to   *
*     store what the user prefers.                                 *
*                                                                  *
********************************************************************

      SUBROUTINE CUTUSER(PFINEL,PFINPOS,ICUT)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION PFINEL(0:3),PFINPOS(0:3)
*      
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI
      COMMON/CHANNEL/ICH
      COMMON/PIINVMASS/PIQ2
      common/expcuts/thmin,thmax,emin,zmax,egmin,thgmin,thgmax
      common/phot_cuts/icutphotons
*
*  ICUT = 1 --> event accepted
*  ICUT = 0 --> event rejected
*
      ICUT = 1

      EEL  = PFINEL(0)
      EPOS = PFINPOS(0) 

      IF(EEL.LT.EMIN.OR.EPOS.LT.EMIN) ICUT = 0
      
      PEL  = SQRT(PFINEL(1)**2+PFINEL(2)**2+PFINEL(3)**2)
      PPOS = SQRT(PFINPOS(1)**2+PFINPOS(2)**2+PFINPOS(3)**2)
*
      CEL  = PFINEL(3)/PEL
      THEL = ACOS(CEL)
*
      CPOS  = PFINPOS(3)/PPOS
      THPOS = ACOS(CPOS)
*
      Z=ABS(PI-THPOS-THEL)    ! acollinearity angle
*
      if (thel.lt.thmin.or.thel.gt.thmax)   icut = 0
      if (thpos.lt.thmin.or.thpos.gt.thmax) icut = 0
      if (z.gt.zmax) icut = 0

      i_all = 1
      if (icutphotons.eq.1) call cuts_on_photons(i_all)

      if (i_all.ge.1) i_all = 1

      icut = icut*i_all

      RETURN
      END   
**************************************************************
* Subroutine to impose cuts on the generated photons: 
*        i = 0 ---> no photons lie within the cuts
*        i > 0 ---> i photons lie within the cuts
**
      subroutine CUTS_ON_PHOTONS(i)
      implicit real*8 (a-h,o-z)
      dimension qph(40,0:3)
      common/const/alpha,convfac,pi,ame,ammu,ampi
      common/expcuts/thmin,thmax,emin,zmax,egmin,thgmin,thgmax
      common/allphotons/qph
*      
* the matrix qph(i,j) has the momenta of the 40 photons (i=1,40)
*
      i = 0
      
      do k = 1,40
         eg = qph(k,0)
         th = 0.d0
         
         if (eg.gt.0.d0) th = acos(qph(k,3)/eg)
         
         if ((th.gt.thgmin.and.th.lt.thgmax).and.
     >    (eg.gt.egmin)) i = i+1
      enddo

      return
      end


*
*
********************************************************
*      |PION FORM FACTOR|^2 
*
       function pffm2(q2)
       implicit real*8 (a-z)
       complex*16 pff,bwr,bwrp,bwo
       complex*16 i   ! imaginary unit !!
       common/const/alpha,convfac,pi,ame,ammu,ampi
       common/pffparams/mo,go,mr,gr,mrp,grp,apff,bpff

       i = (0.d0,1.d0)

       a = apff
       b = bpff

       goq2 = go

       grq2 = gr*mr*mr/q2*(q2-4.d0*ampi*ampi)**(1.5d0)/
     &     (mr*mr-4.d0*ampi*ampi)**(1.5d0)

       grpq2 = grp*mrp*mrp/q2*(q2-4.d0*ampi*ampi)**(1.5d0)/
     &     (mrp*mrp-4.d0*ampi*ampi)**(1.5d0)

       BWr   = mr**2/(mr**2-q2-i*sqrt(q2)*grq2)
       BWrp  = mrp**2/(mrp**2-q2-i*sqrt(q2)*grpq2)
       BWo   = mo**2/(mo**2-q2-i*sqrt(q2)*goq2)

       pff   = BWr*(1.d0+a*BWo)/(1.d0+a)+b*BWrp
       pff   = pff/(1.d0+b)

       PFFM2 = pff*conjg(pff)
       
       return
       end
*
*********************************************************************
*
      subroutine FILL_EVENT(p,q,qph,event)
      implicit real*8 (a-h,o-z)
      dimension p(0:3),q(0:3),qph(40,0:3),qphot1(0:3),qphot2(0:3)
      real*4 event(12)
*
* p(0:3) and q(0:3) are the momenta of the outgoing charged particles,
* qph(40,0:3) contains the photons momenta. qphot1 is the momentum of
* the most energetic photon and qphot2 is the momentum of the
* next-to-most energetic photon. event(12) is the array which is then
* stored.
*
* If you modify this subroutine, maybe you want also to change the tags
* which will appear in the HBOOK file: this can be done modifying the
* subroutine INIT_CHTAGS, which is below....
*
      call pick_2g(qph,qphot1,qphot2)  ! picks out the two most energetic
                                       ! photons, which are then stored
*
       DO I=1,3
	  EVENT(I)  = QPHOT1(I)
          EVENT(3+I)= QPHOT2(I)
       ENDDO
*
       DO I=1,3
          EVENT(6+I) = P(I) 
          EVENT(9+I) = Q(I)
       ENDDO

      return
      end
*
**********************************************************************
*
      subroutine INIT_CHTAGS(chtags)

      CHARACTER*4 CHTAGS(12)

      chtags(1)  = 'QXH1'
      chtags(2)  = 'QYH1'
      chtags(3)  = 'QZH1'
      chtags(4)  = 'QXH2'
      chtags(5)  = 'QYH2'
      chtags(6)  = 'QZH2'
      chtags(7)  = 'PXE'
      chtags(8)  = 'PYE'
      chtags(9)  = 'PZE'
      chtags(10) = 'PXP'
      chtags(11) = 'PYP'
      chtags(12) = 'PZP'

      return
      end

      subroutine bby_init( nMode, ebInput, angleMin, 
     +                     angleMax,energyMin, acolMax )
*
***********************************************************************
***********************************************************************
*
*    MAIN PROGRAM: BABAYAGA 3.5
*                                                   
***********************************************************************
***********************************************************************
*
      IMPLICIT REAL*8 (A-H,O-Z)

      INTEGER nMode
      REAL*8 ebInput
      INTEGER nFinal_State_Rad, nRunning_Alpha
      REAL*8 angleMin, angleMax, energyMin,  acolMax

      REAL*8 QPHOT1(0:3),QPHOT2(0:3),PFINEL(0:3),PFINPOS(0:3)
      CHARACTER*1 INTUPLE,PHCUT,LLG,CUTG
      REAL*4 EVENT(12),RVEC2(2),PH(1)                      
      REAL*8 PM(0:3),PMIRR(0:3),PP(0:3),PPIRR(0:3) 
      REAL*8 QMIRR(0:3),QPIRR(0:3),VCM(0:3)
      REAL*8 mo,mr,mrp,P1(0:3)
      REAL*8 y(10),x(40),qph(40,0:3) 

      INTEGER Oalpha,on
*
cbkh      PARAMETER (LUX=4,K1=0,K2=0)
cbkh      PARAMETER (NWPAWC=10000000)
*      
cbkh      COMMON/PAWC/PAW(NWPAWC)
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI
      COMMON/CHANNEL/ICH
      COMMON/PIINVMASS/PIQ2
      COMMON/FOTONI/NPHO  
      common/phot_cuts/icutphotons
      common/allphotons/qph
      common/allleptons/PFINEL,PFINPOS,QPHOT1,QPHOT2
      common/switchFSR/on,ill
      common/switcharun/iarun
      common/expcuts/thmin,thmax,emin,zmax,egmin,thgmin,thgmax
      common/PFFparams/mo,go,mr,gr,mrp,grp,apff,bpff
      common/resonances/ires
*
      CHARACTER*4  CHTAGS(12)
      CHARACTER*20 OUTFILE,STORFILE
      CHARACTER*15 INFILE

************************************************************************
*
* Important parameters are set....
*
      ALPHA   = 1.D0/137.0359895D0   
      AME     = 0.51099906D-3      ! electron mass
      AMMU    = 105.658389D-3      ! muon mass
      AMPI    = 139.56995D-3       ! pion mass

      CONVFAC = 0.389379660D6      ! conversion factor from natural
                                   ! units to nanobarn
      Oalpha  = 0

      on     = 1     ! by default, FSR is switched on
      iarun  = 1     ! by default alpha is running
      ires   = 1     ! by default hadronic resonances are included

      ebeam = ebInput
      ich   = nMode
      thmin = angleMin
      thmax = angleMax
      zmax = acolMax 
      emin  = energyMin

      on    = 0
      if( ich .le. 2 ) on = 1

      if (ich.eq.1.and.emin.lt.ame)  emin = ame
      if (ich.eq.2.and.emin.lt.ammu) emin = ammu
      if (ich.eq.4.and.emin.lt.ampi) emin = ampi

      iarun = 1
      ires  = 1

      ILL = 0

      if (ich.eq.2.and.on.eq.0) ILL = 1
      if (ich.ge.3) ILL = 1

      intuple = 'N'
      storfile = ' '
      outfile = ' '

      maxnev = 0
      iwriout = 9999999

      phcut = 'N'

      CUTG = 'N'
      icutphotons = 0
      
      egmin  = 0.d0
      thgmin = 0.d0
      thgmax = 180.d0

      if( ich .eq. 4 ) then
        mo = 0.7819
        go = 0.00843
        mr = 0.7865
        gr = 0.1507
        mrp = 1.37
        grp = 0.51
        apff = 0.00185
        bpff = -0.145
      endif
      


*******************************************************************
      
*
* Printing input to the screen
*

      if (ich.eq.1) print*,' Simulated process: e+ e-  -->  e+ e- '
      if (ich.eq.2) print*,' Simulated process: e+ e-  -->  mu+ mu- '
      if (ich.eq.3) print*,' Simulated process: e+ e-  -->  gamma gamma'
      if (ich.eq.4) print*,' Simulated process: e+ e-  -->  pi+ pi-'

      write(*,'(1x,A,f7.4,A)')' Beam energy: ',ebeam,' GeV'

      write(*,'(1x,A,f8.3,A,f8.3,A)')
     >     ' Angular cuts: ',thmin,' deg. - ',thmax,' deg.'

      write(*,'(1x,A,f11.6,A)')' Minimum energy: ',emin,' GeV'

      write(*,'(1x,A,f8.4,A)')' Maximum acollinearity: ',zmax,' deg.'
      print*,' '      

      if (icutphotons.eq.0) print*,' No cuts are imposed on photons'
      if (icutphotons.eq.1) write(*,'(1x,A,f7.4,A,f8.4,A,f8.4,A)')
     >     ' Photon cuts:',egmin,' GeV,',thgmin,' deg. -',thgmax,' deg.'

      if (on.eq.1) print*,' FSR is switched on'
      if (on.eq.0) print*,' FSR is switched off'

      if (iarun.eq.1.and.ich.ne.3) print*,' Alpha is running'
      if (iarun.eq.0.and.ich.ne.3) print*,' Alpha is not running'

      if (ires.eq.1.and.ich.le.2) print*,
     >     ' Hadronic resonances are included'
      if (ires.eq.0.and.ich.le.2) print*,
     >     ' Hadronic resonances are not included'

cbkh      if (intuple.eq.'Y') print*,' Events stored in file: ',STORFILE
cbkh      if (intuple.eq.'N') print*,' Events not stored'

      if (ich.eq.3) then
        print*,' Phcut (for double counting in e+ e- ----> gamma gamma):
     >        ',phcut
      endif
      if (ich.eq.4) then
         write(*,*)' Pion Form Factor parameters:'
         write(*,'(1x,A,f8.5,A,f8.5,A)')
     >        '  Omega mass and width ',mo,' Gev - ',go,' GeV'
         write(*,'(1x,A,f8.5,A,f8.5,A)')
     >        '  Rho mass and width   ',mr,' Gev - ',gr,' GeV'
         write(*,'(1x,A,f8.5,A,f8.5,A)')
     >        '  Rho'' mass and width  ',mrp,' Gev - ',grp,' GeV'
         write(*,'(1x,A,f8.5,A,f8.5,A)')
     >        '  A and B parameters   ',apff,' - ',bpff
      endif

      print*,' '
      print*,' BEGINNING GENERATION.... '
      print*,' '
*
**************************************************************************
*
*
      PI    = 4.D0*ATAN(1.D0)
      ZMAX  = ZMAX*PI/180.D0
      THMIN = THMIN*PI/180.D0
      THMAX = THMAX*PI/180.D0

      thgmin = thgmin*pi/180.d0
      thgmax = thgmax*pi/180.d0

      CMIN = COS(THMAX)
      CMAX = COS(THMIN)
      LEN2 = 2
*
      Q2MIN   = EXP(1.D0)*AME**2 
      Q2MINMU = EXP(1.D0)*AMMU**2
      PIQ2    = 4.d0*ampi**2

**************************************************************
*
      CTRL=0.D0 ! it controls if the integrand function goes up
      		! the maximum
      NCALLS=0    
*
*
      wsum  = 0.d0   ! weighted integration
      wsum2 = 0.d0

      nev = 0
      return 

      entry bby_event( ebeam_event )
      ebeam = ebeam_event

      RS = 2.D0*EBEAM
      S  = RS**2 
*
      EPS = 1.D-5
      if (Oalpha.gt.0) eps = 1.d-5
*
      EPSP=AME/EBEAM  
*
***********************************************************
* HIT OR MISS MAXIMUM IS CALCULATED (SDMAX).  
*
      X1MIN=EMIN/EBEAM
      A=(1.D0-X1MIN)/(1.D0+X1MIN)
*
      CMAXCM=(CMAX+A)/(1.D0+A*CMAX)
*
      SMAX=4.D0*EMIN**2
*
      FATT = (PNB(S,Q2MIN,EPS)/PNOB(S,Q2MIN,EPS,EPSP))**2
*
      IF (ICH.EQ.1) THEN
         ALNE = LOG(EPS)
         AIEPS= -2.D0*ALNE-1.5D0+2.D0*EPS-0.5D0*EPS**2 
         AI   = LOG((1.D0-EPS)/EPSP*((1.D0-EPSP)/EPS)**2)-1.D0
     >          +EPS+EPSP
       IF (AIEPS.LT.AI) THEN
          Q2F=S*(1.D0-CMIN)/(1.D0+CMIN)
        ELSE
           Q2F=S*(1.D0-CMAX)/(1.D0+CMAX) 
       ENDIF
       FATT=(PNB(Q2F,Q2MIN,EPS)/PNOB(Q2F,Q2MIN,EPS,EPSP))**2
*
       SDMAX=SDIF(S,0.D0)/4.5D0*(4.D0+(1.D0+CMAX)**2)
     >      -SDIF(S,0.D0)/4.5D0*(1.D0-CMIN)*(5.D0*CMIN+CMIN**2
     >      +CMIN**3+1.D0)
*
       SDMAX = FATT*SDMAX
     >      *(CMAX-CMIN)/(1.D0-CMIN)/(1.D0-CMAX) 
      ENDIF
*
      IF (ICH.EQ.2) THEN
      SDMAX=FATT*SDIF(S,0.d0)*(CMAX-CMIN)
     >      *(1.D0+CMAX**2+4.D0*AMMU**2/SMAX)
      ENDIF
*
      IF (ICH.EQ.3) THEN
         ANORM = 0.5D0*LOG((1.D0-CMIN)*(1.D0+CMAX)/
     >        (1.D0+CMIN)/(1.D0-CMAX)) 
*
         SDMAX = FATT*SDIF(S,CMAX)*ANORM*(1.D0-CMAX**2)
      ENDIF

      if (ich.eq.4) then
         piq2 =  (0.7726d0)**2
         sdmax = fatt*sdif(piq2,0.d0)*(cmax-cmin)/1.5d0
         sdmax = sdmax / 9.0d1 ! to speed up PiPair mode 
         if (Oalpha.gt.0) sdmax = sdmax/fatt*2.5d0
      endif


      BIN=SQRT(1.D0-AME**2/EBEAM**2)
      PM(0)=EBEAM
      PM(1)=0.D0
      PM(2)=0.D0
      PM(3)=BIN*EBEAM 
*	 	
      PP(0)=EBEAM
      PP(1)=0.D0
      PP(2)=0.D0
      PP(3)=-BIN*EBEAM 

*
cbkh      DO 30, NEV = 1,MAXNEV
      nev = nev + 1
*
 113    CALL RANLUX(RVEC2,LEN2)
*
       NCALLS=NCALLS+1 
*
       CALL RANLUX(PH,1)
       PHIFS=2.D0*PI*PH(1)
*        
      IF (ICH.EQ.1) THEN 
         CCM = ((CMAX-CMIN)*RVEC2(1)+(1.D0-CMAX)*CMIN)/
     >        (1.D0-CMAX+(CMAX-CMIN)*RVEC2(1))   
      ENDIF
      IF (ICH.EQ.2.OR.ICH.EQ.4) THEN
         CCM = (CMAX-CMIN)*RVEC2(1)+CMIN
      ENDIF
      IF (ICH.EQ.3) THEN
         ESP=EXP(2.D0*ANORM*RVEC2(1))
         CCM=((1.D0+CMIN)*ESP-(1.D0-CMIN))/
     >        ((1.D0+CMIN)*ESP+(1.D0-CMIN)) 
      ENDIF   
*
        THETAL=ACOS(CCM)
*
        TCM = -0.5D0*S*(1.D0-CCM)
        UCM = -0.5D0*S*(1.D0+CCM)
        IF (ICH.EQ.1) Q2MAX = S*TCM/UCM
        IF (ICH.GE.2.or.on.eq.0) Q2MAX = S 
        IF (ICH.EQ.2.and.on.eq.1)Q2MAX = S*TCM/UCM
*
**   if (Oalpha.eq.0) then  ! for order alpha PS
*
* ALL-ORDER PHOTONS SHOWERS FROM FERMIONS:
*
* INITIAL STATE ELECTRON.....
*
           CALL PHOTS(Q2MIN,Q2MAX,EPS,EPSP,y,nemi,n10mi)
*
           do k=1,10
              x(k)=y(k)
           enddo
*
* .... INITIAL STATE POSITRON.....
*
           CALL PHOTS(Q2MIN,Q2MAX,EPS,EPSP,y,nepi,n10pi)
*
           do k=1,10
              x(k+10)=y(k)
           enddo

           FSQ2M=Q2MIN
           IF (ICH.EQ.2) FSQ2M=Q2MINMU  
*
* .... FINAL STATE ELECTRON.....
*
           CALL PHOTT(FSQ2M,Q2MAX,EPS,y,nemf,n10mf)        
*     
           do k=1,10
              x(k+20)=y(k)
           enddo	
*
* ... AND FINAL STATE POSITRON.
*	
           CALL PHOTT(FSQ2M,Q2MAX,EPS,y,nepf,n10pf)        
*
           do k=1,10
              x(k+30)=y(k)
           enddo
*
**  else                                      ! for order alpha PS           
**           call PSoal(Q2MAX,Q2MIN,EPS,x)  ! for order alpha PS
**   endif                                    ! for order alpha PS
*
        xel=1.d0
	xpos=1.d0
*
	do k=1,10
         xel=xel*x(k)
	 xpos=xpos*x(k+10)
	enddo
*
	if (ich.eq.1) amaa=ame
	if (ich.eq.2) amaa=ammu
        if (ich.eq.3) amaa=0.d0
        if (ich.eq.4) amaa=ampi
*
        call kinematics(pm,pp,amaa,x,ccm,phifs,qmirr,qpirr,qph,iwr)

        if (iwr.gt.0) goto 113
*
        SHAT=XEL*XPOS*S
*
* ANGULAR CUT ON ISR PHOTONS TO AVOID DOUBLE COUNTING IN 
* GAMMA GAMMA FINAL STATE
*
        ENGMAX = EMIN
        IF (PHCUT.EQ.'Y') THEN
         DO K=1,40  
          COSG = 1.D0
          ENG = qph(k,0)
          IF (ENG.GT.1.D-12) COSG=qph(K,3)/ENG
          IF (COSG.GT.CMIN.AND.COSG.LT.CMAX.AND.ENG.GT.ENGMAX) 
     >      GOTO 113 
         ENDDO
        ENDIF
*
        DO K=0,3
           PFINEL(K)=QMIRR(K)        
        ENDDO
*      
        DO K=0,3
           PFINPOS(K)=QPIRR(K)        
        ENDDO
*
*  EXPERIMENTAL CUTS
*
      do i = 0,3
         p1(i)=pfinpos(i)+pfinel(i)
      enddo

      PIQ2 = dot(p1,p1)

      CALL CUTUSER(PFINEL,PFINPOS,ICUT)
      IF(ICUT.LT.1) GO TO 113

*
* HIT OR MISS
*
        IF (ICH.EQ.1) THEN
          XJAC=((1.D0-CCM)**2)*(CMAX-CMIN)/
     >              ((1.D0-CMAX)*(1.D0-CMIN))
        ENDIF   
        IF (ICH.EQ.2.OR.ICH.EQ.4) THEN
          XJAC=(CMAX-CMIN)
        ENDIF
        IF (ICH.EQ.3) THEN
          XJAC=ANORM*(1.D0-CCM**2)
        ENDIF
*
        COSCM=CCM           
*
        SDCM = SDIF(SHAT,COSCM)*XJAC 

        if (Oalpha.eq.0) then
           SDCM = SDCM*XEL*XPOS
           SDCM = SDCM
     >       *(PNB(Q2MAX,Q2MIN,EPS)/PNOB(Q2MAX,Q2MIN,EPS,EPSP))**2
        endif
*
      IF (SDCM.GT.SDMAX) THEN 
        CTRL=CTRL+1.D0
      ENDIF
* 
      
      wsum  = wsum  + sdcm      ! for weighted cross section
      wsum2 = wsum2 + sdcm**2

      CSI=RVEC2(2)*SDMAX
      IF(CSI.GT.SDCM) GOTO 113     
*
*    
* CROSS SECTION CALCULATION (nb)
*
      XNCALLS = 1.D0*NCALLS
      XNEV    = 1.D0*NEV
      R       = XNEV/XNCALLS
      SEZ     = R*SDMAX*CONVFAC 
      wsez    = wsum/xncalls*convfac
*
* STATISTICAL ERROR IN THE CROSS SECTION CALCULATION
*
      VAR  = SQRT(R*(1.D0-R)/XNCALLS)
      ERR  = VAR*SDMAX*CONVFAC 
      werr = (wsum2/xncalls-(wsez/convfac)**2)/xncalls
*      original line, should be undestood why it is smaller than zero
*      werr = sqrt(werr)*convfac

      if ( werr .ge. 0.0 ) then
         werr = sqrt(werr)*convfac
      else
         werr = -sqrt(-werr)*convfac 
      endif

      return
      entry bby_finishup
*
* INSTRUCTIONS TO PRINT OUTPUTS ON FILE 'OUTFILE'
*
cbkh      IF (NEV.EQ.MAXNEV.OR.MOD(NEV,IWRIOUT).EQ.0) THEN
      WRITE(6,*) '  '
      WRITE(6,'(A,A,A)')
     >     '------ INPUTS (from file: ',infile,') ------'
      WRITE(6,*)' '

      IF (ICH.EQ.1) WRITE(6,*)' PROCESS: e+ e- ----> e+ e- '
      IF (ICH.EQ.2) WRITE(6,*)' PROCESS: e+ e- ----> mu+ mu- '
      IF (ICH.EQ.3) WRITE(6,*)' PROCESS: e+ e- ----> gamma gamma '
      IF (ICH.EQ.4) WRITE(6,*)' PROCESS: e+ e- ----> pi+ pi- '
      WRITE(6,*)' '

      WRITE(6,'(1x,A,f7.4,A)')' EBEAM  = ',EBEAM,' GeV'
      WRITE(6,'(1x,A,f8.4,A,f8.4,A)')
     >     ' ANGULAR CUTS ',thmin*180/pi,' - ',thmax*180/pi,' deg.'  
      WRITE(6,'(1x,A,f7.4,A)')' EMIN   = ',emin,' GeV'
      WRITE(6,'(1x,A,f8.4,A)')' ACOLL. = ',zmax*180/pi,' deg.'

      if (icutphotons.eq.1) WRITE(6,'(1x,A,f7.4,A,f8.4,A,f8.4,A)')
     >     ' Photon cuts: ',egmin,' GeV,',
     >     thgmin*180/pi,' deg. -',thgmax*180/pi,' deg.'
      WRITE(6,*)' '

      if (on.eq.1) WRITE(6,*)' FSR is switched on'
      if (on.eq.0) WRITE(6,*)' FSR is switched off'

      if (iarun.eq.1.and.ich.ne.3) WRITE(6,*)' Alpha is running'
      if (iarun.eq.0.and.ich.ne.3) WRITE(6,*)' Alpha is not running'

      if (ires.eq.1.and.ich.le.2) WRITE(6,*)
     >     ' Hadronic resonances are included'
      if (ires.eq.0.and.ich.le.2) WRITE(6,*)
     >     ' Hadronic resonances are not included'

      if (icutphotons.eq.0) WRITE(6,*)' No cuts are imposed on photons'

      IF (ICH.EQ.3) WRITE(6,*)' PHCUT = ',PHCUT

      if (ich.eq.4) then
         write(6,*)' Pion Form Factor parameters:'
         write(6,'(1x,A,f8.5,A,f8.5,A)')
     >        '  Omega mass and width ',mo,' Gev - ',go,' GeV'
         write(6,'(1x,A,f8.5,A,f8.5,A)')
     >        '  Rho mass and width   ',mr,' Gev - ',gr,' GeV'
         write(6,'(1x,A,f8.5,A,f8.5,A)')
     >        '  Rho'' mass and width  ',mrp,' Gev - ',grp,' GeV'
         write(6,'(1x,A,f8.5,A,f8.5,A)')
     >        '  A and B parameters   ',apff,' - ',bpff
      endif
      WRITE(6,*)' '


      WRITE(6,*)'----------------- OUTPUTS --------------------'
      WRITE(6,*)' '
      WRITE(6,*)' EVENT NUMBER ',NEV,' OF ',MAXNEV
      WRITE(6,*)' '
      if (ctrl.gt.0) then
         WRITE(6,*)CTRL,' (CTRL) WARNING: SDMAX TOO SMALL '
         WRITE(6,*)CTRL/XNCALLS,' (CTRL/NCALLS)'
      endif

      WRITE(6,'(1x,A,f7.5)')' Monte Carlo efficiency: ',R

      WRITE(6,*)'  '
      WRITE(6,*)' UNWEIGHTED CROSS SECTION'
      WRITE(6,'(f14.7,A,f14.7,A)')SEZ,'   +-',ERR,' (nb)'

      WRITE(6,*)'  '
      WRITE(6,*)' WEIGHTED CROSS SECTION'
      WRITE(6,'(f14.7,A,f14.7,A)')WSEZ,'   +-',WERR,' (nb)'
      WRITE(6,*)'  '
*     
cbkh      ENDIF 

      return
      END
*
************** END OF MAIN PROGRAM ******************
*****************************************************
*
* PARTON SHOWER FOR INITIAL-STATE RADIATION. 
* IT CALCULATES D(X,Q2MAX)/X.
*
      SUBROUTINE PHOTS(Q2MIN,Q2MAX,EPS,EPSP,x,nb,n10)
      IMPLICIT REAL*8 (A-H,O-Z)
      dimension x(10) 
      REAL*4 RVEC1(1),VEC(1)
* 
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI
      COMMON/CHANNEL/ICH
      COMMON/CME/EBEAMC     
      COMMON/NUMPHOT/NPHOTEV      
      COMMON/FOTONI/NPHO
*
      do k=1,10
       x(k)=1.d0
      enddo 
*
* INTEGRAL OF AP SPLITTING FUNCTION
*
      ALNE=LOG(EPS)
      AIEPS=-2.D0*ALNE-1.5D0+2.D0*EPS-0.5D0*EPS**2 
      AI=LOG((1.D0-EPS)/EPSP*((1.D0-EPSP)/EPS)**2)-1.D0+EPS+EPSP
*    	 	
* PARTON-SHOWER ALGORITHM
*
      n10=0  
      NPHOTEV=0
      AK2=Q2MIN
*
 110  CALL RANLUX(RVEC1,1)
*
      DVEC=1.D0*RVEC1(1)
*
      PROBNB=PNOB(Q2MAX,AK2,EPS,EPSP)
*      
      IF (DVEC.LE.PROBNB) GOTO 111
*
      NPHOTEV=NPHOTEV+1  
      
      if (nphotev.gt.10) n10=1 
*
* VIRTUALITY EXTRACTION FROM SUDAKOV FORM FACTOR (FUNCTION PNB)   
*
      AKP2=-2.D0*PI/ALPHA/AI*LOG(DVEC) 
*
      AKP2=AK2*EXP(AKP2)                  
*
* X GENERATION FROM AP SPLITTING FUNCTION (P(X)/X....) 
*
      CALL APOVERX(y,EPS,EPSP)
      if (nphotev.le.10) x(nphotev)=y  
*
      AK2=AKP2   
      GO TO 110 
*
* VARIABLES ARE ROTATED TO THE LAB. FRAME
*
 111   CONTINUE
*
      nb=nphotev 
*
      RETURN
      END
*
*-------------------------------------------------------------
*
* PARTON SHOWER FOR FINAL-STATE RADIATION. Generated x according to D(x,s)
*
      SUBROUTINE PHOTT(Q2MIN,Q2MAX,EPS,x,nb,n10)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION  x(10) 
      PARAMETER (LEN1=1)
      REAL*4 RVEC1(1)
* 
      integer on
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI
      COMMON/CHANNEL/ICH
      COMMON/CME/EBEAMC    
      COMMON/NUMPHOT/NPHOTEV
      common/switchFSR/on,ill
*
      DO I=1,10
         X(I)=1.D0
      ENDDO
*
      ALNE=LOG(EPS)
      AIEPS=-2.D0*ALNE-1.5D0+2.D0*EPS-0.5D0*EPS**2 
*
      n10=0
      NPHOTEV=0
* 
      AK2=Q2MIN
*
      IF (on.eq.0) GOTO 113
*
      IF (ICH.EQ.1) AMA=AME
      IF (ICH.EQ.2) AMA=AMMU
*
 101  CALL RANLUX(RVEC1,1)
*
      DVEC=1.D0*RVEC1(1)
*   
      PROBNB=PNB(Q2MAX,AK2,EPS)
*      
      IF (DVEC.LE.PROBNB) GOTO 113
*
      NPHOTEV=NPHOTEV+1   
      if (nphotev.gt.10) n10=1
*
      AKP2=-2.D0*PI/ALPHA/AIEPS*LOG(DVEC) 
*
      AKP2=AK2*EXP(AKP2)                  
*
      CALL PEFRAC(Y,EPS)
*
      IF(NPHOTEV.LE.10) X(NPHOTEV)=Y
*
      AK2=AKP2
*
      GO TO 101 
 113  CONTINUE
*
      nb=nphotev
*
      RETURN
      END
*
***********************************************************************
*
* Next soubroutine has been taken from Drell-Yan program, because it's
* much cleaner and more "readable" than the one in BABAYAGA 3.0....
* It is also much faster!
*
***********************************************************************
*
      subroutine kinematics(pm,pp,ama,y,ccm,phi,p3,p4,qph,ie)

* y(40) contains the FERMIONS energy fractions, x(40) the PHOTONS fractions 

      implicit real*8 (a-h,o-z)
      dimension x(40),vboost(0:3),xf(4),y(40),pm(0:3),pp(0:3),
     >          qph(40,0:3),ptmp(0:3),dir3(0:3),dir4(0:3)
      real*8 mf(4),mtotfs,tmp2(0:3),kone(0:3),ver(0:3),p3(0:3),p4(0:3)
      real*4 rvec(2),csi(1)
      integer on,leg(4)
      common/switchFSR/on,ill      
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI

      ie = 0

      do k = 1,4
         xf(k)  = 1.d0
         leg(k) = 0
      enddo

      do k = 1,10         
         xf(1)=xf(1)*y(k)
         xf(2)=xf(2)*y(10+k)
         xf(3)=xf(3)*y(20+k)
         xf(4)=xf(4)*y(30+k)      
      enddo

      mf(1) = ame
      mf(2) = ame
      mf(3) = ama
      mf(4) = ama
      
      E1 = pm(0)
      E2 = pp(0)

      scm  = sqrt(1.d0 - ccm*ccm)
      sphi = sin(phi)
      cphi = cos(phi)
      
      mtotfs = mf(3)+mf(4)

      do k = 1,40
        x(k) = 1.d0-y(k)
        qph(k,0) = 0.d0
        qph(k,1) = 0.d0
        qph(k,2) = 0.d0
        qph(k,3) = 0.d0
      enddo      

      if (xf(1).eq.1.d0.and.xf(2).eq.1.d0.and.
     >    xf(3).eq.1.d0.and.xf(4).eq.1.d0) then
         
         Etot = E1 + E2
         
         E3 = (Etot**2+mf(3)**2-mf(4)**2)/2.d0/Etot
         E4 = Etot-E3
         
         b3 = (1.d0+mf(3)/E3)*(1.d0-mf(3)/E3)
         b3 = sqrt(b3)
         
         b4 = (1.d0+mf(4)/E4)*(1.d0-mf(4)/E4)
         b4 = sqrt(b4)
         
         p3(1) = b3*E3*sphi*scm
         p3(2) = b3*E3*cphi*scm
         p3(3) = b3*E3*ccm
         p3(0) = E3
         
         p4(1) = -p3(1)   
         p4(2) = -p3(2)   
         p4(3) = -p3(3)   
         p4(0) =  E4

         return
      endif    

      do k=1,10
         if (x(k).gt.0.d0)    leg(1)=leg(1)+1
         if (x(k+10).gt.0.d0) leg(2)=leg(2)+1
         if (x(k+20).gt.0.d0) leg(3)=leg(3)+1
         if (x(k+30).gt.0.d0) leg(4)=leg(4)+1
      enddo

      i_rigenera   = 1
      n_rigenerati = 0

      DO WHILE(i_rigenera.eq.1) !--------------------------------------------
*
      n_rigenerati = n_rigenerati + 1
* 
* This is the DO LOOP for weighting coherent photons....
*
      do k=0,3
         vboost(k) = 0.d0
         kone(k)   = 0.d0
      enddo      
*
* the beta and gamma of the boost due to QED radiation are calculated
* 
      bqed = (xf(1)-xf(2))/(xf(1)+xf(2))
      gqed = 1.d0/sqrt(1.d0-bqed*bqed)
*
* The momenta of the FS particles in the CM are reconstructed and boosted back
*
      E3 = xf(1)*E1*gqed*(1.d0-bqed)  ! E3 and E4 must be equal...
      E4 = xf(2)*E2*gqed*(1.d0+bqed)

! I mantain fully massive kinematics for final state....
      
      Etot = E3 + E4
      
      E3 = (Etot**2+mf(3)**2-mf(4)**2)/2.d0/Etot
      E4 = Etot-E3

      if (E3.lt.mf(3).or.E4.lt.mf(4)) then
         ie = 1
         return
      endif
      
      b3 = (1.d0+mf(3)/E3)*(1.d0-mf(3)/E3)
      b3 = sqrt(b3)
      
      b4 = (1.d0+mf(4)/E4)*(1.d0-mf(4)/E4)
      b4 = sqrt(b4)
            
      p3(1) = b3*E3*cphi*scm
      p3(2) = b3*E3*sphi*scm
      p3(3) = b3*E3*ccm
      p3(0) = E3

      p4(1) = -p3(1)   
      p4(2) = -p3(2)   
      p4(3) = -p3(3)   
      p4(0) =  E4   
     
      vboost(3) = -bqed
            
      call boost(gqed,vboost,p3,p3)
      call boost(gqed,vboost,p4,p4)
*
* Once boosted back, p3 and p4 are degradated for QED radiation....
*      
!      p3modmo = 1.d0/sqrt(tridot(p3,p3))
!      p4modmo = 1.d0/sqrt(tridot(p4,p4))

*** dir3 and dir4 contain the directions along with I'll generate PS photons

      do i = 0,3
         dir3(i) = p3(i)
         dir4(i) = p4(i)
      enddo
**
      E3before = p3(0)
      E4before = p4(0)
      
      E3after = p3(0)*xf(3)
      E4after = p4(0)*xf(4)

      if (E3after.lt.mf(3).or.E4after.lt.mf(4)) then
         ie = 2
         return
      endif
             
      b1 = (1+mf(1)/E1)*(1-mf(1)/E1)
      b1 = sqrt(b1)
      b2 = (1+mf(2)/E2)*(1-mf(2)/E2)
      b2 = sqrt(b2)
      b3 = (1+mf(3)/E3after)*(1-mf(3)/E3after)
      b3 = sqrt(b3)
      b4 = (1+mf(4)/E4after)*(1-mf(4)/E4after)
      b4 = sqrt(b4)
    
********** PHOTONS are reconstructed ***********

      o1 = E1
      o2 = E2
      o3 = E3before
      o4 = E4before
         
      do k = 1,10
      
         qph(k,0)    = o1*x(k)
         qph(k+10,0) = o2*x(k+10)
         qph(k+20,0) = o3*x(k+20)
         qph(k+30,0) = o4*x(k+30)
      
         o1 = o1 - qph(k,0)
         o2 = o2 - qph(k+10,0)
         o3 = o3 - qph(k+20,0)
         o4 = o4 - qph(k+30,0)
     
*** Photons angles....

         if (qph(k,0).gt.0.d0) then 
            
            call ranlux(rvec,2)
            phph = 2.d0*pi*rvec(1)
            
            an  = -1.d0/b1*log((1.d0-b1)/(1.d0+b1))
            cth = (1.d0 - (1.d0+b1)*
     #           exp(-b1*an*rvec(2)))/b1
      
            sth = sqrt(1.d0-cth*cth)
            cph = cos(phph)
            sph = sin(phph)
            
            qph(k,1) = qph(k,0)*sph*sth
            qph(k,2) = qph(k,0)*cph*sth
            qph(k,3) = qph(k,0)*cth
            
         endif
**       
         if (qph(k+10,0).gt.0.d0) then 

            call ranlux(rvec,2)
            phph = 2.d0*pi*rvec(1)
            
            an  = -1.d0/b2*log((1.d0-b2)/(1.d0+b2))
            cth = (1.d0 - (1.d0+b2)*
     #           exp(-b2*an*rvec(2)))/b2
            
            sth = sqrt(1.d0-cth*cth)
            cph = cos(phph)
            sph = sin(phph)
            
            qph(k+10,1) = qph(k+10,0)*sph*sth
            qph(k+10,2) = qph(k+10,0)*cph*sth
            qph(k+10,3) = qph(k+10,0)*cth
            
         endif
**
         if (qph(k+20,0).gt.0.d0) then 
            
            call ranlux(rvec,2)
            phph = 2.d0*pi*rvec(1)
            
            an  = -1.d0/b3*log((1.d0-b3)/(1.d0+b3))
            cth = (1.d0 - (1.d0+b3)*
     #           exp(-b3*an*rvec(2)))/b3
            
            sth = sqrt(1.d0-cth*cth)
            cph = cos(phph)
            sph = sin(phph)
            
            qph(k+20,1) = qph(k+20,0)*sph*sth
            qph(k+20,2) = qph(k+20,0)*cph*sth
            qph(k+20,3) = qph(k+20,0)*cth
            
         endif
**
         if (qph(k+30,0).gt.0.d0) then 
            
            call ranlux(rvec,2)
            phph = 2.d0*pi*rvec(1)
            
            an  = -1.d0/b4*log((1.d0-b4)/(1.d0+b4))
            cth = (1.d0 - (1.d0+b4)*
     #           exp(-b4*an*rvec(2)))/b4
      
            sth = sqrt(1.d0-cth*cth)
            cph = cos(phph)
            sph = sin(phph)
            
            qph(k+30,1) = qph(k+30,0)*sph*sth
            qph(k+30,2) = qph(k+30,0)*cph*sth
            qph(k+30,3) = qph(k+30,0)*cth
            
         endif
**
      enddo

* reporting photons in the lab system....

***************************************************
      tmp2(0) =  1.d0
      tmp2(1) =  0.d0
      tmp2(2) =  0.d0
      tmp2(3) = -1.d0

      do k = 1,10
**       
       if (qph(k+10,0).gt.0.d0) then

          ptmp(0) = qph(k+10,0)
          ptmp(1) = qph(k+10,1)
          ptmp(2) = qph(k+10,2)
          ptmp(3) = qph(k+10,3)
       
          call rotnew(-1,tmp2,ptmp,ptmp)
          
          qph(k+10,0) = ptmp(0) 
          qph(k+10,1) = ptmp(1) 
          qph(k+10,2) = ptmp(2)
          qph(k+10,3) = ptmp(3)
          
       endif
**       
       if (qph(k+20,0).gt.0.d0) then

          ptmp(0) = qph(k+20,0)
          ptmp(1) = qph(k+20,1)
          ptmp(2) = qph(k+20,2)
          ptmp(3) = qph(k+20,3)
          
          call rotnew(-1,dir3,ptmp,ptmp)
          
          qph(k+20,0) = ptmp(0) 
          qph(k+20,1) = ptmp(1) 
          qph(k+20,2) = ptmp(2)
          qph(k+20,3) = ptmp(3)
       
       endif
**      
       if (qph(k+30,0).gt.0.d0) then

          ptmp(0) = qph(k+30,0)
          ptmp(1) = qph(k+30,1)
          ptmp(2) = qph(k+30,2)
          ptmp(3) = qph(k+30,3)
       
          call rotnew(-1,dir4,ptmp,ptmp)
          
          qph(k+30,0) = ptmp(0) 
          qph(k+30,1) = ptmp(1) 
          qph(k+30,2) = ptmp(2)
          qph(k+30,3) = ptmp(3)

       endif
**
      enddo
*
* I recalculate p3 and p4 in order to have exact 4-momentum conservation...
* The strategy is analogous to the one used in BABAYAGA
*
      do k = 1,40
         do j = 0,3
            kone(j) = kone(j)+qph(k,j)
         enddo
      enddo        
      
      ptmp(0) = E1+E2-kone(0)
      ptmp(1) = -kone(1)
      ptmp(2) = -kone(2)
      ptmp(3) = b1*E1-b2*E2-kone(3)
      
      if (dot(ptmp,ptmp).lt.mtotfs**2) then
       ie = 3 
       return
      endif 
      
      vboost(0) = 0.d0
      vboost(1) = ptmp(1)/ptmp(0)
      vboost(2) = ptmp(2)/ptmp(0)
      vboost(3) = ptmp(3)/ptmp(0)
      
      bcm = sqrt(vboost(1)**2+vboost(2)**2+vboost(3)**2)
      gcm = 1.d0/sqrt(1.d0-bcm**2)
 
      call boost(gcm,vboost,ptmp,ptmp)

      Etot = ptmp(0)

      E3 = (Etot**2+mf(3)**2-mf(4)**2)/2.d0/Etot
      E4 = Etot-E3

      if (E3.lt.mf(3).or.E4.lt.mf(4)) then
      	ie = 4
        return
      endif	

      b3 = (1.d0+mf(3)/E3)*(1.d0-mf(3)/E3)
      b3 = sqrt(b3)      
      b4 = (1.d0+mf(4)/E4)*(1.d0-mf(4)/E4)
      b4 = sqrt(b4)
*
* Now I use "versori" directed as dir3 and dir4. This do not mean that
* p3 and p4 will be directed as dir3 and dir4 when boosted back in the lab.,
* because they are massive! But this is not a real problem and it is implicit
* in the 2-body approximation of the PS....
*            
      call ranlux(csi,1)

      if (csi(1).lt.0.5) then

         p3modmo = 1.d0/sqrt(tridot(dir3,dir3))        
         ver(0) = 1.d0          ! I forgot masses....
         ver(1) = dir3(1)*p3modmo
         ver(2) = dir3(2)*p3modmo
         ver(3) = dir3(3)*p3modmo

      else

         p4modmo = 1.d0/sqrt(tridot(dir4,dir4))
         ver(0) = 1.d0          ! I forgot masses....
         ver(1) = dir4(1)*p4modmo
         ver(2) = dir4(2)*p4modmo
         ver(3) = dir4(3)*p4modmo

      endif

      call boost(gcm,vboost,ver,ver)
*
**********************************************************
* from /home/carlo/PhDThesis/programs/CNL+babayaga/kinematics_test_forsub.f 
* IT IS NOT CORRECT!
*********************************************************
*      v = bcm
* 
*      cvb=tridot(vboost,ver)/v
*      
*      bp=sqrt(1.d0-mf(3)**2/E3**2)
*      
*      abig=gcm**2*(1.d0-bp**2)
*      
*      ax=(1.d0+v**2*abig*cvb**2) 
*      bx=-2.d0*abig*v*cvb
*      cx=abig-1.d0
*      
*      blab=-bx+sqrt(bx**2-4.d0*ax*cx)
*      blab=blab/2.d0/ax
*      
*      print*,blab,'IL PRINT é QUI!!!! ' 
*
*      elab=1.d0/(1.d0-blab**2)*mf(3)**2
*      elab=sqrt(elab)
*
*      ver(0)=elab
*      ver(1)=elab*blab*ver(1)
*      ver(2)=elab*blab*ver(2)
*      ver(3)=elab*blab*ver(3)
*
*      call boost(gcm,vboost,ver,ver) 
*     
*      v = sqrt(ver(1)**2+ver(2)**2+ver(3)**2)
*      
*      ver(1) = ver(1)/v
*      ver(2) = ver(2)/v
*      ver(3) = ver(3)/v
****************************************************
*****************************************************
*
      if (csi(1).lt.0.5) then
 
         vermo = 1.d0/sqrt(tridot(ver,ver))

         p3(1) = b3*E3*ver(1)*vermo
         p3(2) = b3*E3*ver(2)*vermo
         p3(3) = b3*E3*ver(3)*vermo
         p3(0) = E3

         p4(1) = -p3(1)   
         p4(2) = -p3(2)   
         p4(3) = -p3(3)   
         p4(0) =  E4

      else

         vermo = 1.d0/sqrt(tridot(ver,ver))

         p4(1) = b4*E4*ver(1)*vermo
         p4(2) = b4*E4*ver(2)*vermo
         p4(3) = b4*E4*ver(3)*vermo
         p4(0) = E4

         p3(1) = -p4(1)   
         p3(2) = -p4(2)   
         p3(3) = -p4(3)   
         p3(0) =  E3      
      endif
         
      do i=0,3
       vboost(i)=-vboost(i)
      enddo  

      call boost(gcm,vboost,p3,p3)
      call boost(gcm,vboost,p4,p4)

* Now I weight photon angular distribution to account for
* coherence effects...
      
      ww=wrongw(pm,pp,dir3,dir4,qph)       

      wok=weight(pm,pp,dir3,dir4,qph)
       
      call ranlux(csi,1)
      rho=1.d0*csi(1)  
      
      nphot=leg(1)+leg(2)+leg(3)+leg(4)
      
      tetto=ww

      abbassatetto = (1.d0 + ill)*(0.65d0-ill*0.05d0)

      tetto = tetto/abbassatetto
        
      if (nphot.gt.2) tetto=tetto/nphot*3.d0
      
      cfr=rho*tetto

***      if (tetto.lt.wok) print*,'warning: tetto < wok ',wok/tetto,leg

      if (cfr.gt.wok) i_rigenera = 1
      if (cfr.lt.wok) i_rigenera = 0
      
      ENDDO !-----------------------------------------------------
*            
      return
      end

******************************************************************

      subroutine rotnew(idir,vect,pin,pout)
      implicit real*8 (a-h,o-z)       
      real*8 pin(0:3), pout(0:3),pp(0:3),r(3,3),vers(3),vect(0:3)
*
* This subroutine rotate the 4-vector pin in the frame where the z-axis is
* directed along the 4-vector vect(0,1,2,3). The rotated vector is stored
* in pout
*
* idir =  1 ---> direct rotation matrix
* idir = -1 ---> inverse rotation matrix
*      
      pp(0) = pin(0)
      pp(1) = pin(1)
      pp(2) = pin(2)
      pp(3) = pin(3)
      
      vmo = 1.d0/sqrt(vect(1)**2+vect(2)**2+vect(3)**2)
      
      vers(1) = vect(1)*vmo
      vers(2) = vect(2)*vmo
      vers(3) = vect(3)*vmo
            
      vt = sqrt(vers(1)**2+vers(2)**2)         
C       v1ovt = vers(1)/vt
C      if (vt.eq.0.d0) v1ovt = 0.d0

C       v2ovt = vers(2)/vt
C      if (vt.eq.0.d0) v2ovt = 1.d0

C     to avoid problem when vt == 0.0
      if (vt.eq.0.d0) then
         v1ovt = 0.d0
         v2ovt = 1.0d0
      else
         v1ovt = vers(1)/vt
         v2ovt = vers(2)/vt
      endif
         
      
      if (idir.eq.(-1)) then !! INVERSE rotation matrix

         r(1,1) =  vers(3)*v1ovt
         r(1,2) = -v2ovt
         r(1,3) =  vers(1)
         
         r(2,1) =  vers(3)*v2ovt
         r(2,2) =  v1ovt
         r(2,3) =  vers(2)
      
         r(3,1) = -vt
         r(3,2) =  0.d0
         r(3,3) =  vers(3)      

      else ! if (idir.eq.1) !! DIRECT rotation matrix
 
         r(1,1) =  vers(3)*v1ovt
         r(2,1) = -v2ovt
         r(3,1) =  vers(1)
         
         r(1,2) =  vers(3)*v2ovt
         r(2,2) =  v1ovt
         r(3,2) =  vers(2)
         
         r(1,3) = -vt
         r(2,3) =  0.d0
         r(3,3) =  vers(3)      
     
      endif
            
      pout(0) = pp(0)
      pout(1) = r(1,1)*pp(1) + r(1,2)*pp(2) + r(1,3)*pp(3)
      pout(2) = r(2,1)*pp(1) + r(2,2)*pp(2) + r(2,3)*pp(3)
      pout(3) = r(3,1)*pp(1) + r(3,2)*pp(2) + r(3,3)*pp(3)
      
      return
      end

********************************************************

      function weight(p1,p2,p3,p4,q)
      
      implicit real*8 (a-h,o-z)       
      dimension p1(0:3),p2(0:3),p3(0:3),p4(0:3),qc(40,0:3)
      dimension q(40,0:3),qa(0:3),pij(4,4),pidq(4)
      integer on
      COMMON/CHANNEL/ICH
      common/switchFSR/on,ill
         
         iyfs = 1-ill

         pij(1,1) =    -dot(p1,p1)
         pij(2,1) =     dot(p2,p1)
         pij(3,1) =  on*dot(p3,p1)*iyfs
         pij(4,1) = -on*dot(p4,p1)*iyfs
         pij(1,2) =     dot(p1,p2)
         pij(2,2) =    -dot(p2,p2)
         pij(3,2) = -on*dot(p3,p2)*iyfs
         pij(4,2) =  on*dot(p4,p2)*iyfs
         pij(1,3) =  on*dot(p1,p3)*iyfs
         pij(2,3) = -on*dot(p2,p3)*iyfs
         pij(3,3) = -on*dot(p3,p3)
         pij(4,3) =  on*dot(p4,p3)
         pij(1,4) = -on*dot(p1,p4)*iyfs
         pij(2,4) =  on*dot(p2,p4)*iyfs
         pij(3,4) =  on*dot(p3,p4)
         pij(4,4) = -on*dot(p4,p4)      

*!*!*!*!*!*!*!      
      w=1.d0  
   
      do k=1,40
        do i=0,3
	  qc(k,i)=0.d0  
        enddo
      enddo 

      j=1
      do k=1,40 
      
        if (q(k,0).ne.0.d0) then
          do i=0,3
	   qc(j,i)=q(k,i)
          enddo
         j=j+1       
        endif
      enddo 

      kmax=j-1
      do k=1,kmax
      
      if (qc(k,0).ne.0.d0) then
      
        do i=0,3
         qa(i)=qc(k,i)
        enddo 	      
      
        pidq(1)=dot(p1,qa)
        pidq(2)=dot(p2,qa)
        pidq(3)=dot(p3,qa)
        pidq(4)=dot(p4,qa)
      
        wql=0.d0
         
        do i=1,4
          do j=1,4
           wql=wql+pij(i,j)/pidq(i)/pidq(j)*qa(0)*qa(0)
          enddo 
        enddo 
       endif
            
      w=w*wql/k
                
      enddo

      weight=w

      end
*
********************************************************
*
      function wrongw(p1,p2,p3,p4,q)
      
      implicit real*8 (a-h,o-z)       
      dimension p1(0:3),p2(0:3),p3(0:3),p4(0:3),qc(40,0:3)
      dimension q(40,0:3),qa(0:3),p(4,0:3),pidq(4)
      integer on
      common/switchFSR/on,ill

      w=1.d0  
 
      do j=0,3
         p(1,j)=p1(j)
      enddo
      do j=0,3
         p(2,j)=p2(j)
      enddo      
      do j=0,3
         p(3,j)=p3(j)
      enddo      
      do j=0,3
         p(4,j)=p4(j)
      enddo 
 
      do k=1,40
         do i=0,3
            qc(k,i)=0.d0  
         enddo
      enddo 

      j=1

      do k=1,40       
         if (q(k,0).ne.0.d0) then
            do i=0,3
               qc(j,i)=q(k,i)
            enddo
            j=j+1       
         endif
      enddo 

      kmax=j-1

      do k=1,kmax
         if (qc(k,0).ne.0.d0) then
            do i=0,3
               qa(i)=qc(k,i)
            enddo 	
            pidq(1)=dot(p1,qa)
            pidq(2)=dot(p2,qa)
            pidq(3)=dot(p3,qa)
            pidq(4)=dot(p4,qa)
            wql=0.d0
************ warning! think about the factor 4....      
            imax = 4
** ONLY ISR ------ i = 1 and 2!!!!!!

            if (on.eq.0) imax = 2

            do i=1,imax
               wql=wql+4.d0*1.d0/pidq(i)*qa(0)*p(i,0)
            enddo 
            
         endif
      
         w=w*wql/k
      enddo

      wrongw=w
       
      end
*
*-----------------------------------------------------------------------
*
       subroutine boost(g,v,p,q)
       implicit real*8 (a-h,o-z)       
       real*8 p(0:3),q(0:3),pp(0:3),v(0:3)
*
       do i = 0,3
          pp(i) = p(i)
          q(i)  = p(i)
       enddo
*
       if (g.eq.1.d0) goto 666
*       
       ppdv = tridot(pp,v)
       v2   = v(1)**2+v(2)**2+v(3)**2
*
       q(0) = g*(pp(0)-ppdv)
       do i = 1,3
          q(i) = pp(i)+(g-1.d0)*ppdv/v2*v(i)-g*v(i)*pp(0)
       enddo
*
 666   return
       end
*
********************************************************
*
      subroutine pick_2g(q,q1,q2)
      implicit real*8 (a-h,o-z)
      dimension q(40,0:3),q1(0:3),q2(0:3)
* 
*  LEADING ENERGETIC PHOTON IS EXTRACTED
*
        do i = 0,3
           q1(i) = 0.d0
           q2(i) = 0.d0
        enddo

        sum = q(1,0)+q(11,0)+q(21,0)+q(31,0)
        
        if (sum.lt.1.d-11) return
        
        ENPHOT = Q(1,0)
        ENHARD = ENPHOT
        J=1
* 
        DO I = 1,40
           ENPHOT = Q(I,0)
           IF (ENHARD.GE.ENPHOT) THEN
              ENHARD = ENHARD
           ELSE
              J = I
              ENHARD = ENPHOT
           ENDIF
        ENDDO 
*   
        ENHARDL = ENHARD
        JL = J
*
        if (j.gt.0) then
           DO I = 0,3
              Q1(I) = Q(J,I)
           ENDDO
        endif
*
*  NEXT-TO-LEADING ENERGETIC PHOTON IS EXTRACTED
*
      ENHARD = 0.D0
      J = 0
* 
      DO I = 1,40
         IF (I.NE.JL) THEN
*
            ENPHOT = Q(I,0)
            IF (ENHARD.GE.ENPHOT) THEN
               ENHARD = ENHARD
            ELSE
               J = I
               ENHARD = ENPHOT
            ENDIF
*     
         ENDIF
      ENDDO 
*   
      ENHARD = ENHARD
*
      if (j.gt.0) then
         DO I = 0,3
            Q2(I) = Q(J,I)
         ENDDO
      endif
      return
      end

********************************************************
*       
*-----------------------------------------------------------------------
*  DIRECT ROTATION MATRIX
*
       SUBROUTINE ROTDIR(PHI,CTETA,PROTT,PLABB)
       implicit real*8 (a-h,o-z)       
       REAL*8 PROTT(0:3), PLABB(0:3),P(0:3),RDIR(3,3)
*
       STETA=SQRT(1.D0-CTETA**2)
       CPHI=COS(PHI)
       SPHI=SIN(PHI)
*
* ELEMENTS OF THE ROTATION MATRIX:
*
       RDIR(1,1)=CTETA*CPHI
       RDIR(2,1)=-SPHI
       RDIR(3,1)=STETA*CPHI
*
       RDIR(1,2)=CTETA*SPHI
       RDIR(2,2)=CPHI
       RDIR(3,2)=STETA*SPHI
*
       RDIR(1,3)=-STETA
       RDIR(2,3)=0.D0
       RDIR(3,3)=CTETA
*
* PLABA CALCULATION
*
       DO I=0,3
         P(I)=PROTT(I)
       ENDDO
* 
        PLABB(0)=P(0)
       DO I=1,3
        PLABB(I)=RDIR(I,1)*P(1)+RDIR(I,2)*P(2)
     >          +RDIR(I,3)*P(3)
       ENDDO
*
       RETURN
       END
*
*---------------------------------------------------------------------------
*
       FUNCTION DOT(P,Q)
*
       IMPLICIT REAL*8 (A-H,O-Z)
       REAL*8 P(0:3),Q(0:3)       
*
       DOT=P(0)*Q(0)-P(1)*Q(1)-P(2)*Q(2)-P(3)*Q(3)       
*
       RETURN
       END
*
*-------------------------------------------------------------------------
*
       FUNCTION TRIDOT(P,Q)
*
       IMPLICIT REAL*8 (A-H,O-Z)
       REAL*8 P(0:3),Q(0:3)       
*
       TRIDOT = P(1)*Q(1)+P(2)*Q(2)+P(3)*Q(3)       
*
       RETURN
       END
*
*------------------------------------------------------------------
*     ROTATION MATRIX
*
       SUBROUTINE ROT(PHI,CTETA,PROT,PLAB)
       IMPLICIT REAL*8 (A-H,O-Z)       
       REAL*8 PROT(0:3), PLAB(0:3),PP(0:3),RINV(3,3)
*
       STETA=SQRT(1.D0-CTETA**2)
       CPHI=COS(PHI)
       SPHI=SIN(PHI)
*
* ELEMENTS OF THE ROTATION MATRIX:
*
       RINV(1,1)=CTETA*CPHI
       RINV(1,2)=-SPHI
       RINV(1,3)=STETA*CPHI
*
       RINV(2,1)=CTETA*SPHI
       RINV(2,2)=CPHI
       RINV(2,3)=STETA*SPHI
*
       RINV(3,1)=-STETA
       RINV(3,2)=0.D0
       RINV(3,3)=CTETA
*
* PLAB CALCULATION
*
       DO I=0,3
        PP(I)=PROT(I)
       ENDDO
*
        PLAB(0)=PP(0)
       DO I=1,3
        PLAB(I)=RINV(I,1)*PP(1)+RINV(I,2)*PP(2)
     >          +RINV(I,3)*PP(3)
       END DO
*
       RETURN
       END
*
*-----------------------------------------------------
*   DIFFERENTIAL CROSS SECTION
*
       FUNCTION SDIF(S,C)
       IMPLICIT REAL*8 (A-H,O-Z)
       REAL*8 AM(14),GT(14),GE(14)
       COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI
       COMMON/CHANNEL/ICH
       COMMON/PIINVMASS/PIQ2
       common/resonances/ires
*
* AM=HADRON MASSES, GT=TOTAL WIDTH, GE=PARTIAL E+E- WIDTH.
*
* 1=RHO, 2=OMEGA, 3=PHI, 4=J/PSI, 5=PSI(2S), 6=PSI(3770), 7=PSI(4040),
* 8=PSI(4160), 9=PSI(4415), 10=Y, 11=Y(2S), 12=Y(4S), 13=Y(10860),
* 14=Y(11020).
*
       DATA AM/0.770D0,0.782D0,1.019413D0,3.09688D0,3.686D0,3.7699D0,
     >         4.040D0,4.159D0,4.415D0,9.46037D0,10.02330D0,10.5800D0,
     >         10.865D0,11.019D0/
       DATA GT/0.1507D0,8.41D-3,4.43D-3,87.D-6,277.D-6,23.6D-3,
     >         52.D-3,78.D-3,43.D-3,52.5D-6,44.D-6,10.D-3,
     >         110.D-3,79.D-3/
       DATA GE/6.77D-6,0.60D-6,1.32457D-6,5.26D-6,2.14D-6,0.26D-6,
     >         0.75D-6,0.77D-6,0.47D-6,1.32D-6,0.520D-6,0.248D-6,
     >         0.31D-6,0.130D-6/
*
* QED DIFFERENTIAL CROSS SECTIONS (WITH OR WITHOUT RUNNING ALPHA):
*
      IF (ICH.EQ.3) then 
         SQED = 0.5D0*2.D0*PI*ALPHA**2*
     >        (1.D0+C**2)/(1.D0-C**2)/S
         SDIF = SQED
         return
      endif
*
      IF (ICH.EQ.4) then          
         BET  = SQRT(1.D0-4.D0*AMPI**2/S)
         SQED = 2.d0*pi*alpha**2*bet**3*(1-c**2)/8.d0/s
         SQED = SQED*PFFM2(PIQ2)
         SQED = SQED*(VPOL(S))**2
         SDIF = SQED
         return
      ENDIF
*
      T=-(1.D0-C)*S/2.D0
      COT=PI*(ALPHA*VPOL(T))**2/S
      SDT=COT*((1.D0+C)**2+4.D0)/((1.D0-C)**2) 
      COS=PI*(ALPHA*VPOL(S))**2/(2.D0*S)
      SDS=COS*(1.D0+C**2)
      COST=PI*ALPHA**2*VPOL(S)*VPOL(T)/S
      SDST=-COST*(1.D0+C)**2/(1.D0-C)
*
* HADRON-EXCHANGE CONTRIBUTIONS
*
      SDHAD=0.D0
*
      if (ires.eq.1) then
         DO J=1,14
*
            V=3.D0*GE(J)/AM(J)
            DEN=(S-AM(J)**2)**2+(GT(J)*AM(J))**2
*     
            SDH=PI*V**2*(1.D0+C**2)*S/2.D0/DEN
            SDHS=PI*ALPHA*VPOL(S)*V*
     >           (1.D0+C**2)*(S-AM(J)**2)/DEN
            SDHT=-PI*ALPHA*VPOL(T)*V*
     >           ((1.D0+C)**2/(1-C))*(S-AM(J)**2)/DEN
*     
            IF (ICH.EQ.1) SDHAD=SDHAD+SDH+SDHS+SDHT
*     
            IF (ICH.EQ.2) SDHAD=SDHAD+SDH+SDHS
*     
         ENDDO    
      endif
* 
* DIFFERENTIAL CROSS SECTIONS SUM 
*
      IF (ICH.EQ.1) SQED = SDS+SDT+SDST
      IF (ICH.EQ.2) THEN
         BET=SQRT(1.D0-4.D0*AMMU**2/S)
         SQED=COS*BET*(1.D0+C**2+
     >        4.D0*AMMU**2/S*(1.D0-C**2))
      ENDIF
*      
      SDIF = SQED+SDHAD
*
      RETURN
      END
********************************************************
*
*  X GENERATION ACCORDING TO AP SPLITTING FUNCTION  
*  (1+X^2)/(1-X), 0 <= X <= 1-EPS
*
      SUBROUTINE PEFRAC(X,EPS)
      IMPLICIT REAL*8 (A-H,O-Z)
*
      PARAMETER (LEN2=2)
      REAL*4 RVEC2(LEN2)
*
      ALNE = LOG(EPS)
      AIEPS =-2.D0*ALNE-1.5D0+2.D0*EPS-0.5D0*EPS**2 
  120 CALL RANLUX(RVEC2,LEN2)
      CX = RVEC2(1)
*
      OMX = EXP(CX*ALNE)
      X = 1.D0 - OMX
*
      RX = RVEC2(2)*2.D0/OMX
      PX = (1.D0 + X**2)/OMX
      IF (RX.GT.PX) GO TO 120
*
      RETURN
      END
*-----------------------------------------------------
*
*  X GENERATION ACCORDING TO AP(X)/X SPLITTING FUNCTION  
*  (1+X^2)/(1-X)/X, EPSP <= X <= 1-EPS
*
      SUBROUTINE APOVERX(X,EPS,EPSP)
      IMPLICIT REAL*8 (A-H,O-Z)
*
      PARAMETER (LEN2=2)
      REAL*4 RVEC2(LEN2)
*
      XP=1.D0-EPS
      XM=EPSP
*
      A=LOG(XP/XM*(1.D0-XM)/(1.D0-XP)) 
  120 CALL RANLUX(RVEC2,LEN2)
      CX = 1.D0*RVEC2(1)
*
      X = XM*EXP(CX*A)/(1.D0+XM*(EXP(CX*A)-1.D0))
      OMEX=1.D0-X
* 
***      IF (OMEX.EQ.0.D0) PRINT*,CX,EXP(CX*A),X,'!!!'
      IF (OMEX.EQ.0.D0) OMEX = 1.D0
      RX = RVEC2(2)*2.D0/OMEX/X
      PX = (1.D0 + X**2)/OMEX/X
      IF (RX.GT.PX) GO TO 120
*
      RETURN
      END
*
*-----------------------------------------------------
* NO-BRANCHING PROBABILITY (SUDAKOV FORM FACTOR) 
*
      FUNCTION PNB(Q2,QP2,EPS)
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI
      COMMON/CHANNEL/ICH
*
      AIEPS =-2.D0*LOG(EPS)-1.5D0+2.D0*EPS-0.5D0*EPS**2
      PNB = -ALPHA/2.D0/PI*LOG(Q2/QP2)*AIEPS
      PNB = EXP(PNB)
*
      RETURN
      END
*-----------------------------------------------------
* NO-BRANCHING PROBABILITY FOR D(X,S)/X
*     
      FUNCTION PNOB(Q2,Q2P,EPS,EPSP)
      IMPLICIT REAL*8 (A-H,O-Z)
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI 
*
      PNOB=LOG((1.D0-EPS)/EPSP*((1.D0-EPSP)/EPS)**2)-1.D0+EPS+EPSP
      PNOB=EXP(-ALPHA/2.D0/PI*LOG(Q2/Q2P)*PNOB) 
      RETURN
      END
*
*-----------------------------------------------------
* VACUUM POLARIZATION: ALPHA(0)->ALPHA(0)*VPOL(Q2)
*
      FUNCTION VPOL(Q2) 
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*4 QIN4,ST24,DER4,ERRDER4,DEG4,ERRDEG4
      DIMENSION AMASSES(4)
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI
      COMMON/CHANNEL/ICH
      common/switcharun/iarun
*
* E,MU,TAU,TOP MASSES: 
*
      DATA AMASSES /0.510999D-3,.1056584D0,1.777D0,175.6D0/
*
      if (iarun.eq.0) then
         vpol = 1.d0
         return
      endif

      SOMMA=0.D0
      DO I=1,4
       SOMMA=SOMMA+SUMMA(AMASSES(I),Q2,I)
      ENDDO
      AMODQ2=ABS(Q2)

      ST2=0.2322
      QIN=SQRT(AMODQ2)
      QIN=-QIN
      QIN4=QIN
      ST24=ST2
      CALL HADR5(QIN4,ST24,DER4,ERRDER4,DEG4,ERRDEG4)
      DER=DER4
      DEG=DEG4
      ERRDER=ERRDER4
      ERRDEG=ERRDEG4
      DALPHA=ALPHA/PI*SOMMA+DER
      VPOL=1.D0/(1.D0-DALPHA)
*
      RETURN
      END
*
*----------------------------------------------------------
* LEPTONIC AND TOP CONTRIBUTION TO VACUUM POLARIZATION
*
      FUNCTION SUMMA(AM,Q2,I)
*
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 NC(4),QF2(4)
      COMMON/CONST/ALPHA,CONVFAC,PI,AME,AMMU,AMPI
      COMMON/CHANNEL/ICH
*
* NC AND QF ARE COLOR FACTOR (1 FOR LEPTONS, 
* 3 FOR TOP) AND CHARGE
*
      DO J=1,3
        NC(J)=1.D0
        QF2(J)=1.D0
      ENDDO
      NC(4)=3.D0
      QF2(4)=4.D0/9.D0
*
      AM2=AM**2
*
      IF (Q2.GE.0.D0.AND.Q2.LT.(4.D0*AM2)) THEN
*
       SQ=SQRT(4.D0*AM2/Q2-1.D0)
*
       SUMMA=NC(I)*QF2(I)*(-5.D0/9.D0-(4.D0/3.D0)*(AM2/Q2)+
     >    (4.D0/3.D0*(AM2/Q2)**2+1.D0/3.D0*AM2/Q2-1.D0/6.D0)*
     >     4.D0/SQ*ATAN(1.D0/SQ))
*
        ELSE
*
       SQ=SQRT(1.D0-4.D0*AM2/Q2)
       ARGLOG=ABS((1.D0-SQ)/(1.D0+SQ))
*
       SUMMA=NC(I)*QF2(I)*(-5.D0/9.D0-(4.D0/3.D0)*(AM2/Q2)+
     >    (4.D0/3.D0*(AM2/Q2)**2+1.D0/3.D0*AM2/Q2-1.D0/6.D0)*
     >     2.D0/SQ*LOG(ARGLOG))
*
       ENDIF
*
       RETURN
       END
*
*--------------------------------------------------------------------
*  EIDELMAN-JEGERLEHNER HADRONIC CONTRIBUTION TO ALPHA_QED
*

       SUBROUTINE HADR5(E,ST2,DER,ERRDER,DEG,ERRDEG)
C ******************************************************************
C *                                                                *
C *      SUBROUTINE FOR THE EVALUATION OF THE LIGHT HADRON         *
C *           CONTRIBUTIONS TO DELTA_R  AND  DELTA_G               *
C *                    USING FITS TO THE                           *
C *          QED VACUUM POLARIZATION FROM E^+ E^- DATA             *
C *                                                                *
C *    F. JEGERLEHNER, PAUL SCHERRER INSTITUTE, CH-5232 VILLIGEN   *
C *                                                                *
C *    E-MAIL:JEGERLEHNER@CVAX.PSI.CH                              *
C *    PHONE :   +41-56-993662                                     *
C *                                                                *
C *    REFERENCE: F. JEGERLEHNER, Z. PHYS. C32 (1986) 195          *
C *               H. BURKHARDT ET AL., Z. PHYS. C42 (1989) 497     *
C *               S. EIDELMAN, F. JEGERLEHNER, Z. PHYS. C (1995)   *
C *                                                                *
C ******************************************************************
C       VERSION: 24/02/1995
C
C  NOTATION: E ENERGY ( MOMENTUM TRANSFER ): E>0 TIMELIKE , E<0 SPACELIKE
C            ST2 IS SIN^2(THETA); ST2=0.2322 IS THE REFERENCE VALUE
C  THE ROUTINE RETURNS THE HADRONIC CONTRIBUTION OF 5 FLAVORS (U,D,S,C,B)
C                 TO   DER=DELTA_R WITH HADRONIC ERROR ERRDER
C                AND   DEG=DELTA_G WITH HADRONIC ERROR ERRDEG
C  THE EFFECTIVE VALUE OF THE FINE STRUCTURE CONSTANT ALPHAQED AT ENERGY
C  E IS ALPHAQED(E)=ALPHAQED(0)/(1-DELTA_R) ,SIMILARLY FOR THE SU(2)
C  COUPLING ALPHASU2(E)=ALPHASU2(0)/(1-DELTA_G), WHERE DELTA_R(G) IS THE
C  SUM OF LEPTONIC, HADRONIC CONTRIBUTIONS (TOP TO BE ADDED).
C
C  THIS PROGRAM DOES NOT YET KNOW HOW TO COMPUTE DELTA R AND DELTA G FOR
C  ENERGIES IN THE RANGES  |E|>1TEV AND 2M_PI < E < 40(13) GEV !!!!!!!!!
C
       IMPLICIT NONE
       INTEGER *2 NF,NS,I,J
       PARAMETER(NF=9,NS=4)
       REAL *4 E,ST2,ST20,DER,DEG,ERRDER,ERRDEG,S,S0,X1,XI,X2,XLOG,XLAR
       REAL *4 M1(NF),C1(NF,NS),C2(NF,NS),C3(NF,NS),C4(NF,NS),AE(NF,NS)
       REAL *4 EU(NF),EO(NF),RES(NS),L1(NF,NS),FX,GX,HX,XX,U,SE
       DO I=1,NF
         DO J=1,NS
           AE(I,J)=0.0
         ENDDO
       ENDDO
C #1# DELTA_R
C FIT PARAMETERS SPACELIKE  -1000 TO  -200 GEV
      EU(1)  =-1000.
      EO(1)  = -200.
      M1(1)=  -1000.000
      C1(1,1)=  4.2069394E-02
      C2(1,1)=  2.9253566E-03
      C3(1,1)= -6.7782454E-04
      C4(1,1)=  9.3214130E-06
C   CHI2=  2.5763808E-05
C FIT PARAMETERS SPACELIKE  -200 TO  -20 GEV
      EU(2)  = -200.
      EO(2)  =  -20.
      M1(2)  =  -100.0000
      C1(2,1)=  2.8526291E-02
      C2(2,1)=  2.9520725E-03
      C3(2,1)= -2.7906310E-03
      C4(2,1)=  6.4174528E-05
C   CHI2=  6.6264300E-04
C FIT PARAMETERS SPACELIKE   -20 TO   -2 GEV
      EU(3)  =  -20.
      EO(3)  =   -2.
      M1(3)  =   -20.0000
      L1(3,1)=  9.3055E-3
      C1(3,1)=  2.8668314E-03
      C2(3,1)=  0.3514608
      C3(3,1)=  0.5496359
      C4(3,1)=  1.9892334E-04
C   CHI2=  4.2017717E-03
      AE(3,1)=  3.0
C FIT PARAMETERS SPACELIKE    -2 TO    0.25 GEV
      EU(4)  =   -2.
      EO(4)  =    0.25
      M1(4)  =    -2.0000
      L1(4,1)=  9.3055E-3
      C1(4,1)=  2.2694240E-03
      C2(4,1)=   8.073429
      C3(4,1)=  0.1636393
      C4(4,1)= -3.3545541E-05
C   CHI2=  0.1239052
      AE(4,1)=  2.0
C FIT PARAMETERS TIMELIKE   0.25 TO    2 GEV
      EU(5)  =    0.25
      EO(5)  =    2.
C FIT PARAMETERS TIMELIKE   2    TO   40 GEV
      EU(6)  =    2.
      EO(6)  =   40.
C FIT PARAMETERS TIMELIKE     40 TO   80 GEV
      EU(7)  =   40.
      EO(7)  =   80.
      M1(7)  =   80.00000
      C1(7,1)=  2.7266588E-02
      C2(7,1)=  2.9285045E-03
      C3(7,1)= -4.7720564E-03
      C4(7,1)=  7.7295507E-04
C   CHI2=  7.7148885E-05
C FIT PARAMETERS TIMELIKE     80 TO  250 GEV
      EU(8)  =   80.
      EO(8)  =  250.
      M1(8)  =   91.18880
      C1(8,1)=  2.8039809E-02
      C2(8,1)=  2.9373798E-03
      C3(8,1)= -2.8432352E-03
      C4(8,1)= -5.2537734E-04
C   CHI2=  4.2241514E-05
C FIT PARAMETERS TIMELIKE    250 TO 1000 GEV
      EU(9)  =  250.
      EO(9)  = 1000.
      M1(9)  = 1000.00000
      C1(9,1)=  4.2092260E-02
      C2(9,1)=  2.9233438E-03
      C3(9,1)= -3.2966913E-04
      C4(9,1)=  3.4324117E-07
C   CHI2=  6.0426464E-05
C #2# DELTA_G
C FIT PARAMETERS SPACELIKE  -1000 TO  -200 GEV
C     EU(1)  =-1000.
C     EO(1)  = -200.
C     M1(1)=  -1000.000
      C1(1,2)=  8.6415343E-02
      C2(1,2)=  6.0127582E-03
      C3(1,2)= -6.7379221E-04
      C4(1,2)=  9.0877611E-06
C   CHI2=  9.6284139E-06
C FIT PARAMETERS SPACELIKE  -200 TO  -20 GEV
C     EU(2)  = -200.
C     EO(2)  =  -20.
C     M1(2)  =  -100.0000
      C1(2,2)=  5.8580618E-02
      C2(2,2)=  6.0678599E-03
      C3(2,2)= -2.4153464E-03
      C4(2,2)=  6.1934326E-05
C   CHI2=  6.3297758E-04
C FIT PARAMETERS SPACELIKE   -20 TO   -2 GEV
C     EU(3)  =  -20.
C     EO(3)  =   -2.
C     M1(3)  =   -20.0000
      L1(3,2)=  1.9954E-2
      C1(3,2)=  5.7231588E-03
      C2(3,2)=  0.3588257
      C3(3,2)=  0.5532265
      C4(3,2)=  6.0730567E-04
C   CHI2=  7.9884287E-03
      AE(3,2)=  3.0
C   CHI2=  4.2017717E-03
C FIT PARAMETERS SPACELIKE    -2 TO    0.25 GEV
C     EU(4)  =   -2.
C     EO(4)  =    0.25
C     M1(4)  =    -2.0000
      L1(4,2)=  1.9954E-2
      C1(4,2)=  4.8065037E-03
      C2(4,2)=   8.255167
      C3(4,2)=  0.1599882
      C4(4,2)= -1.8624817E-04
C   CHI2=  0.1900761
      AE(3,2)=  2.0
C FIT PARAMETERS TIMELIKE     40 TO   80 GEV
C     EU(7)  =   40.

C     EO(7)  =   80.
C     M1(7)  =   80.00000
      C1(7,2)=  5.5985276E-02
      C2(7,2)=  6.0203830E-03
      C3(7,2)= -5.0066952E-03
      C4(7,2)=  7.1363564E-04
C   CHI2=  7.6000040E-05
C FIT PARAMETERS TIMELIKE     80 TO  250 GEV
C     EU(8)  =   80.
C     EO(8)  =  250.
C     M1(8)  =   91.18880
      C1(8,2)=  5.7575710E-02
      C2(8,2)=  6.0372148E-03
      C3(8,2)= -3.4556778E-03
      C4(8,2)= -4.9574347E-04
C   CHI2=  3.3244669E-05
C FIT PARAMETERS TIMELIKE    250 TO 1000 GEV
C     EU(9)  =  250.
C     EO(9)  = 1000.
C     M1(9)  = 1000.00000
      C1(9,2)=  8.6462371E-02
      C2(9,2)=  6.0088057E-03
      C3(9,2)= -3.3235471E-04
      C4(9,2)=  5.9021050E-07
C   CHI2=  2.9821187E-05
C #3# ERROR DELTA_R
C FIT PARAMETERS SPACELIKE  -1000 TO  -200 GEV
C     EU(1)  =-1000.
C     EO(1)  = -200.
C     M1(1)=  -1000.000
      C1(1,3)=  6.3289929E-04
      C2(1,3)=  3.3592437E-06
      C3(1,3)=  0.0
      C4(1,3)=  0.0
C   CHI2=  2.3007713E-05
C FIT PARAMETERS SPACELIKE  -200 TO  -20 GEV
C     EU(2)  = -200.
C     EO(2)  =  -20.
C     M1(2)  =  -100.0000
      C1(2,3)=  6.2759849E-04
      C2(2,3)= -1.0816625E-06
      C3(2,3)=   5.050189
      C4(2,3)= -9.6505374E-02
C   CHI2=  3.4677869E-04
      AE(2,3)=  1.0
C FIT PARAMETERS SPACELIKE   -20 TO   -2 GEV
C     EU(3)  =  -20.
C     EO(3)  =   -2.
C     M1(3)  =   -20.0000
      L1(3,3)=  2.0243E-4
      C1(3,3)=  1.0147886E-04
      C2(3,3)=   1.819327
      C3(3,3)= -0.1174904
      C4(3,3)= -1.2404939E-04
C   CHI2=  7.1917898E-03
      AE(3,3)=  3.0
C FIT PARAMETERS SPACELIKE    -2 TO    0.25 GEV
C     EU(4)  =   -2.
C     EO(4)  =    0.25
C     M1(4)  =    -2.0000
      L1(4,3)=  2.0243E-4
      C1(4,3)= -7.1368617E-05
      C2(4,3)=  9.980347E-04
      C3(4,3)=   1.669151
      C4(4,3)=  3.5645600E-05
C   CHI2=  0.1939734
      AE(4,3)=  2.0
C FIT PARAMETERS TIMELIKE     40 TO   80 GEV
C     EU(7)  =   40.
C     EO(7)  =   80.
C     M1(7)  =   80.00000
      C1(7,3)=  6.4947648E-04
      C2(7,3)=  4.9386853E-07
      C3(7,3)=  -55.22332
      C4(7,3)=   26.13011
C   CHI2=  7.2068366E-04
C FIT PARAMETERS TIMELIKE     80 TO  250 GEV
C     EU(8)  =   80.
C     EO(8)  =  250.
C     M1(8)  =   91.18880
      C1(8,3)=  6.4265809E-04
      C2(8,3)= -2.8453374E-07
      C3(8,3)=  -23.38172
      C4(8,3)=  -6.251794
C   CHI2=  1.1478480E-07
C FIT PARAMETERS TIMELIKE    250 TO 1000 GEV
C     EU(9)  =  250.
C     EO(9)  = 1000.
C     M1(9)  = 1000.00000
      C1(9,3)=  6.3369947E-04
      C2(9,3)= -2.0898329E-07
      C3(9,3)=  0.0
      C4(9,3)=  0.0
C   CHI2=  2.9124376E-06
C #4# ERROR DELTA_G
C FIT PARAMETERS SPACELIKE  -1000 TO  -200 GEV
C     EU(1)  =-1000.
C     EO(1)  = -200.
C     M1(1)=  -1000.000
      C1(1,4)=  1.2999176E-03
      C2(1,4)=  7.4505529E-06
      C3(1,4)=  0.0
      C4(1,4)=  0.0
C   CHI2=  2.5312527E-05
C FIT PARAMETERS SPACELIKE  -200 TO  -20 GEV
C     EU(2)  = -200.
C     EO(2)  =  -20.
C     M1(2)  =  -100.0000
      C1(2,4)=  1.2883141E-03
      C2(2,4)= -1.3790827E-06
      C3(2,4)=   8.056159
      C4(2,4)= -0.1536313
C   CHI2=  2.9774895E-04
      AE(2,4)=  1.0
C FIT PARAMETERS SPACELIKE   -20 TO   -2 GEV
C     EU(3)  =  -20.
C     EO(3)  =   -2.
C     M1(3)  =   -20.0000
      L1(3,4)=  4.3408E-4
      C1(3,4)=  2.0489733E-04
      C2(3,4)=   2.065011
      C3(3,4)= -0.6172962
      C4(3,4)= -2.5603661E-04
C   CHI2=  7.5258738E-03
      AE(3,4)=  3.0
C FIT PARAMETERS SPACELIKE    -2 TO    0.25 GEV
C     EU(4)  =   -2.
C     EO(4)  =    0.25
C     M1(4)  =    -2.0000
      L1(4,4)=  4.3408E-4
      C1(4,4)= -1.5095409E-04
      C2(4,4)=  9.9847501E-04
      C3(4,4)=   1.636659
      C4(4,4)=  7.5892596E-05
C   CHI2=  0.1959371
      AE(4,4)=  2.0
C FIT PARAMETERS TIMELIKE     40 TO   80 GEV
C     EU(7)  =   40.
C     EO(7)  =   80.
C     M1(7)  =   80.00000
      C1(7,4)=  1.3335156E-03
      C2(7,4)=  2.2939612E-07
      C3(7,4)=  -246.4966
      C4(7,4)=   114.9956
C   CHI2=  7.2293193E-04
C FIT PARAMETERS TIMELIKE     80 TO  250 GEV
C     EU(8)  =   80.
C     EO(8)  =  250.
C     M1(8)  =   91.18880
      C1(8,4)=  1.3196438E-03
      C2(8,4)=  2.8937683E-09
      C3(8,4)=   5449.778
      C4(8,4)=   930.3875
C   CHI2=  4.2109136E-08
C FIT PARAMETERS TIMELIKE    250 TO 1000 GEV
C     EU(9)  =  250.
C     EO(9)  = 1000.
C     M1(9)  = 1000.00000
      C1(9,4)=  1.3016918E-03
      C2(9,4)= -3.6027674E-07
      C3(9,4)=  0.0
      C4(9,4)=  0.0
C   CHI2=  2.8220852E-06
C ######################################################################
       SE=654./643.      ! RESCALING ERROR TO PUBLISHED VERSION 1995
       ST20=0.2322
       S=E**2
       DER=0.0
       DEG=0.0
       ERRDER=0.0
       ERRDEG=0.0
       IF ((E.GT.1.E3).OR.(E.LT.-1.E3)) GOTO 100
       IF ((E.LT.4.E1).AND.(E.GT.0.25)) GOTO 100
       I=1
       DO WHILE (E.GE.EO(I))
         I=I+1
       ENDDO
       IF (E.EQ.1.E3) I=9
       IF (E.EQ.0.0 ) GOTO 100
       S0=SIGN(1.0,M1(I))*M1(I)**2
       S =SIGN(1.0,E)*E**2
       X1=S0/S
       XI=1.0/X1
       X2=X1**2
       IF (AE(I,1).LE.0.0) THEN
         DO J=1,4
           XLAR=XI+AE(I,J)*EXP(-XI)
           XLOG=LOG(XLAR)
           RES(J)=C1(I,J)
     .           +C2(I,J)*(XLOG+C3(I,J)*(X1-1.0)+C4(I,J)*(X2-1.0))
         ENDDO
       ELSE IF (AE(I,1).EQ.2.0) THEN
         HX     =XI**2
         DO J=1,2
           FX     =1.0-C2(I,J)*S
           GX     = C3(I,J)*S/(C3(I,J)-S)
           XX     =LOG(ABS(FX))+C2(I,J)*GX
           RES(J)=C1(I,J)*XX-L1(I,J)*GX+C4(I,J)*HX
         ENDDO
         DO J=3,4
           U      =ABS(S)
           GX     =-C3(I,J)*U/(C3(I,J)+U)
           XX     =XI**3/(SQRT(ABS(XI))**5+C2(I,J))
           RES(J)=C1(I,J)*XX-L1(I,J)*GX+C4(I,J)*HX
         ENDDO
       ELSE IF (AE(I,1).EQ.3.0) THEN
         HX     =XI
         DO J=1,4
           FX     =1.0-C2(I,J)*S
           GX     = C3(I,J)*S/(C3(I,J)-S)
           XX     =LOG(ABS(FX))+C2(I,J)*GX
           RES(J)=C1(I,J)*XX-L1(I,J)*GX+C4(I,J)*HX
         ENDDO
       ENDIF
       DER=RES(1)
       DEG=RES(2)*ST20/ST2
       ERRDER=RES(3)*SE
       ERRDEG=RES(4)*SE
       GOTO 100
C 99    WRITE(*,*) ' OUT OF RANGE! '
100    RETURN
       END
